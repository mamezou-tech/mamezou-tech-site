---
title: 第2回 MicroProfileってなにそれ？ - MicroProfileの仕様と実装
author: toshio-ogiwara
date: 2022-03-10
tags: ["逆張りのMicroProfile"]
prevPage: ./src/posts/msa/microprofile/cntrn01-what-mp.md
nextPage: ./src/posts/msa/microprofile/cntrn03-sampleapp-helidon.md
eleventyExcludeFromCollections: true
---

前回はMicroProfileの登場からMicroProfileが目指すものまで説明させていただきました。今回はMicroProfileの実際の中身であるMicroProfileの仕様と実装について、私見も交えながら説明させていただきたいと思います。若干長い説明となりますが、最後まで目を通していただけたら幸いです。

[[TOC]]

## MicroProfileがカバーする仕様
早速ですがMicroProfile5.0に含まれている仕様[^1]を並べると下のとおりになります。

![mp-spce](./../../../img/mp/mp-spec.png)

[^1]: [公式ページ](https://microprofile.io/)に記載のトップレベル仕様のみ記載


### Jakarta EEやJavaエコシステムの活用
パッと見てCDIやJAX-RSなど見慣れた、もしくは耳にしたことがあるJakarta EEの仕様が含まれているのが分かると思います。これが、正に前回(リンク)のMicroProfileの説明にあった「Jakarta EEや既に存在するJavaエコシステムの活用」に当たります。

昨今のJavaアプリケーション開発ではオブジェクトの管理やオブジェクト間の依存性の注入(Dependency Injection)を行うDIコンテナの利用は必須となっており、そのDIの手段としてMicroProfileではJakarta EEに含まれているCDIを取り入れ活用しています。また、マイクロサービスアーキテクチャでRESTは必須の技術要素となりますが、これについてもJakarta EEのJAX-RSが取り入れられています。

このようにMicroProfileはJakarta EEの仕様がベースとなっているため、Jakarta EEとは非常に親和性の高いAPI体系になっています。


### マイクロサービスアーキテクチャへの考慮
そして、次に注目すべき仕様はOpenTracingやMetricsなどになります。

マイクロサービスアーキテクチャで重要が増す非機能要件として、システムがどのような状態になっているか観測可能かを意味する可観測性と障害から回復しサービスを継続する回復性があります。MicroProfileではこの可観測性と回復性を実現する仕様としてOpenTracingやMetrics、Health, Fault Toleranceが含まれています[^2]。

仕様にこれらが含まれていること点が前回(リンク)説明のあったMicroProfileが「マイクロサービスアーキテクチャで必要となる標準APIや機能を提供する」を目的にしていることをよく表していると思います

[^2]: ただし、可観測性や回復性に対するソリューションは他にも多く存在するため、これの仕様を実際にアプリケーションで利用するかは別とも個人的には思っています


## MicroProfileの各仕様
MicroProfileに含まれる個々の仕様の内容は下記の通りとなります。 それぞれの仕様にはMicroProfileの実装を提供するMicroProfileベンダー観点の仕様とそれを利用する利用者側観点、双方の内容が含まれています（なので若干小難しくなっています）

| 仕様 | 概要[^3] |
| ---- | -------- |
|OpenTracing|MicroProfile のサービスをopentracing.ioの方のOpenTracing機能に<br/>参加させるためのインテグレーション機能に関する仕様|
|OpenAPI|ソースからOAS(Open API Specification)ドキュメントを生成する<br/>ためのアノテーションやドキュメント生成方法を定めた仕様|
|RestClient|インタフェースを定義するだけでREST呼び出しを可能にする仕組みや<br/>利用方法を定めた仕様|
|Config|環境変数やシステムプロパティ、設定ファイルなど異なる設定源の<br/>設定を統合して扱えるようにする仕組みと利用法を定めた仕様|
|Fault Tolerance|いわゆるサーキットブレーカやRetry、Timeoutなどのフォールト<br/>トレラント機能をMicroProfileとして定めたもの|
|Metrics|ヒープ消費やGC回数などのシステムの状況を監視するメトリックスの<br/>収集と公開方法が定義されている。よりイメージしやすく言うとマイクロ<br/>サービスアーキテクチャ向けのJMXのようなもの|
|JWT Auth[^4]|何をしてくれる仕様なのかMicroProfileの中で一番実体が掴みづらい<br/>仕様だが、実体はOIDCをベースにした標準的なclaimに加えRBAC<br/>するために必要となるRoleに関するclaimが定義されたJavaのインタ<br/>フェースとその扱いが定められているだけで、実際の認証と認可を<br/>どのように行うかは定められていない|
|Health|サービスの死活監視に関するいわゆるReadnessとLivenessに関する<br/>仕様を定めたもの|
|CDI|いわゆるDIコンテナに相当するJakarta EEバージョンの仕様|
|JSON-P|"-P"のPはParserのPではなくProcessingのPで、後述するJSON-Bの<br/>ベースになるようなもので、端的に言うとアプリケーションプログ<br/>ラム観点ではこれだけでは使い物にならない（なのでJSON-Bの<br/>ベースと表現しています）|
|JAX-RS|RESTリクエストを送信するRESTクライアントとRESTリクエストを<br/>受信するRESTリソースに関する仕様が定義されています|
|JSON-B|こちらがいわゆるパーサーに関する仕様。その実装としては<br/>jackson-databindが有名と言うとよりピンとくるでしょうか|
|Jakarta Annotations|各仕様間で同じようなannotationがバラバラに定義されないように<br/>共通的なannotationを定義したもの。`@Priority`や`@PostConstruct`など<br/>が定義されています|


[^3]: 個人的な1行コメント的な内容になっています。正確な仕様についてはそれぞれ[JakartaEE Spec](https://jakarta.ee/specifications/)、または[MicroProfile Spec](https://download.eclipse.org/microprofile/microprofile-5.0/microprofile-spec-5.0.html)を参照いただければと思います。
[^4]: この仕様の表記は公式の中でも揺れていて、JWT PropagationやJWT RBACの表記も公式ページに出てきますが、実体はいずれも同じものを指していると思われます。

### （コラム）あれっ、データベースアクセスってどうするの？
MicroProfileの仕様を見てお気づきになった方もいるかと思いますが、MicroProfile仕様にはJPAやJTAなどと言ったRDBに関する仕様は一切含まれていません。

マイクロサービスアーキテクチャではデータベースは必須でなく、またデータベースもRDBともは限りません。ですので、これらに関する仕様が含めていないのは妥当だと思いますが、実際にはRDBが利用されるケースはまだまだ多くあるため、これはかなり思い切った選択だったと思います。

ただ、MicroProfileに含まれてないのは分かったとして、それではどうするの？となると思いますが、この後に説明するMicroProfileの利用形態の一つであるアプリケーションサーバでは、当然Jakarta EEの一部としてJPAやJTAはサポートされますし、個々のMicroProfileフレームワークにも付加機能としてJPAインテグレーションが備えられています。ですので、仕様には含まれませんが、実際にはJPAやJTAもMicroProfileと一緒に利用可能と考えて問題ありません。

### （コラム）基盤としてのCDIとSpring Frameworkとの関係
MicroProfileに含まれる仕様はいくつかの例外を除き、その基盤としてオブジェクトの生成や依存性の注入を行うCDIコンテナが存在することを前提としています。

例えばJAX-RSであれば、JAX-RSを構成するResourceクラスやProviderクラスはCDIコンテナでそのインスタンスが管理されることが前提となっています。また、JAX-RSを使いやすくしたRestClientもJAX-RSがベースですので、おのずとCDIコンテナが前提となります。このため、MicroProfileを使うと言った場合、CDI以外の仕様は必要なものだけを取捨選択することができますが、CDIについてはMicroProfileの基盤となる仕組みであるため、実質的にその利用は必須となります。

これはJavaのアプリケーション開発で広く利用されているSpring Framework(Spring)でも同様となります。SpringもCDIと同様にオブジェクトの生成と依存性の注入を行うSpring独自のDIの仕組みを持っています[^5]。これがSpringのDIコンテナで、Springの他の機能もDIコンテナを前提としており、DIコンテナなくしてSpringは成り立ちません。

このようにSpringとMicroProfileでは目的を同じにした別の仕組みを基盤としているため、両者を1つのアプリケーションで共有して使うことは現実的にあり得ず、どちらか一方を選択することとなります。このことから、MicroProfileとSpringはアーキテクチャ的に排他的な関係にあると言えます。

[^5]: これはむしろJava EEがSpringのDIを後追いで標準化したという方が正しいですが、、

## MicroProfileの実装形態
MicroProfileはあくまでも仕様のため、MicroProfileを使うにはMicroProfile仕様に準拠した実装が必要となり、このMicroProfileの仕様と実装の関係は、基本的にJakarta EEと同じとなります。

例えばJakarta EE仕様の1つであるJPAであれば、その実装としてHibernateやEclipseLinkがありますが、これと同様にMicroProfileも1つの仕様に対していくつか実装の選択肢が存在するものがあります。また、Jakarta EE対応のアプリケーションサーバ（以降、アプリケーションサーバ）であれば、対応しているプロファイル のすべての実装がアプリケーションサーバから提供されます。

よって、アプリケーションサーバ上でWebアプリケーションを稼働させる場合、warのWBE-INF/libにJPAなど利用したい仕様に対する実装（ライブラリ）を個別に配置する必要はありません。

これはJakarta EEの仕様に対する実装や機能が基盤となるアプリケーションサーバから提供されるためです。MicroProfileの仕様や機能を利用する場合も基本的にこれと同様となります。つまり、MicroProfileを利用する場合は対応する基盤を利用ことになります。

と、ここで基盤と敢えてボンヤリ書いたことには理由があります。これはMicroProfileの実装形態が大きく2つあるからです。そこで次からは具体的なMicroProfile対応製品を見ていきたいと思います。

## MicroProfileの実装（製品）
筆者の独断と偏見でMicroProfile仕様の実装[^6] ならコレ！というものを5つ選ばせていただき、ブランドロゴを並べてみました。

![mp-vendors](../../../img/mp/mp-vendors.png)

### Jakarta EEアプリケーションサーバの利用
既に良くご存じの製品も並んでいるかと思います。そうです、MicroProfileを利用するための実装形態の1つは、MicroProfileにも対応したアプリケーションサーバを使うことになります。

OpenLibertyやPayara、WildFlyはJakarta EEはもちろんのこと、MicroProfileにも対応しています。ですので、MicroProfile対応のアプリケーションサーバを使っていれば、追加で何かを導入することなく、MicroProfileの仕様や機能を利用することが可能[^7]です 。また、既にMicroProfile対応アプリケーションサーバで稼働させているアプリケーションであれば、既存のアプリケーションにMicroProfileを利用した処理を追加することももちろん可能です。

[^6]: 他の対応製品については、公式ページで公表されている[リスト](https://wiki.eclipse.org/MicroProfile/Implementation)を参照
[^7]: 製品エディションに対する条件や追加の設定などがある場合があります。必要事項の有無やその内容については利用プロダクトのマニュアル等でご確認ください


### MicroProfileフレームワークの利用
もう1つの形態は、マイクロサービスアーキテクチャで利用されることを目的として開発されたQuarkusやHelidonといったMicroProfileフレームワーク[^8]の利用となります。

マイクロサービスアーキテクチャはアプリケーションサーバ上で稼働させていたモジュラーモノリスと言った比較的大きな1つのアプリケーションを複数のモジュールに分割し、分割した1つ1つのモジュールを独立した1つのJavaプロセスとして動作させるものとなりますが、このモジュールを動作させる基盤としアプリケーションサーバを用いることにはやや問題があります。

それはメモリとフットプリントです。単純に今まで1つで賄っていたアプリケーションサーバを分割したモジュールの数分アプリケーションサーバを用意する必要があると言われた場合、感覚的に「えっ！？」となることは容易に理解いただけるかと思います。

また、一般的にアプリケーションサーバにはServletやJSFといったMPA(MultiPageAction)に関するUI機能や分散トランザクションなどの堅牢性に関する仕組みが多く含まれてきます。アプリケーションによってはこれらが有効に機能するケースはもちろん多くありますが、マイクロサービスアーキテクチャではAPIとしてサービスを提供するのみで、UIを提供することはありません。

また、トランザクションは常にデータの一貫性が求められる分散トランザクションではなく、間隔が空いても最終的にはデータの一貫性が保たれる結果整合性によるトランザクションが一般的に用いられます。

したがって、マイクロサービスアーキテクチャの実行基盤にアプリケーションサーバを用いたい場合、利用しない無駄な機能により大なり小なりメモリとディスクが消費されます。また、端的に不必要に高機能とも言えます

そこでマイクロサービスアーキテクチャの実行基盤の選択肢となるのが、先ほど出てきたQuarkusやHelidon言ったMicroProfileフレームワークになります。MicroProfileフレームワークはそれ自身でWebサーバの機能を内包しているためExecutable Jarとして、javaコマンドから直接起動することができます。つまり、アプリケーションの実行にアプリケーションサーバを必要としません。

また、含まれる機能はMicroProfile実装とフレームワーク固有のマイクロサービスアーキテクチャ向けの機能のみとなり、UIや分散トランザクションと言ったマイクロサービスアーキテクチャで使われることがない機能は含まれません。よって、アプリケーションサーバと比較した場合、軽量となります。

なお、軽量と言うと貧弱なイメージを与えますが、UIを持たずHTTPのエンドポイントとしてサービスを公開するマイクロサービスなアプリケーション開発ではMicroProfileに含まれるAPIで十分事が足ります。このため、既存アプリケーションも一緒に稼働させる必要があるといった制約がない限り、マイクロサービスアーキテクチャの基盤にアプリケーションサーバを選択する理由はないと思います

### （コラム）アプリケーションサーバもかなり良くなっている
以前は重し遅いデバック辛い、、と言ったイメージがあるアプリケーションサーバですが、昨今は必要となるまで機能やモジュールをロードしないようにする遅延ロードの仕組みにより高度に最適化図られているため、起動時にすべて行っていた一昔前とは違い、起動速度もメモリ消費量も段違いで向上しましています。

したがって、マイクロフレームワークが軽量と言っても、昨今アプリケーションサーバと比べて画期的に起動時間が短く、メモリ消費が少なくなるわけではありません。

ただし、アプリケーションサーバのインストールも不要でかつ、jarの配置だけでアプリケーションを稼働させることができるため、その点では圧倒的に「軽量」なのは断言できます

### MicroProfile製品の各紹介
「MicroProfileの実装（製品）」の説明の最後にロゴで挙げさせていただいたMicroProfile対応製品を各種情報と勝手な一口コメントを付けてそれぞれ紹介させていただきます

|プロダクト名|開発元(運営元)|対応Version|一口コメント|
|------------|--------------|:-----------:|------------|
|[OpenLiberty](https://openliberty.io/)|IBM|5.0|製品版のWebSphereLibertyと同様に<br/>MicroProfileの最新バージョンへの追従が<br/>速く、MicroProfileをけん引する製品と<br/>言っても過言ではない|
|[Payara Server](https://www.payara.fish/products/payara-server/)|Payara|3.3|GlassFish Serverから派生してアプリ<br/>ケーションサーバ。コマンドラインからwar<br/>を起動することができる[Payara Micro](https://www.payara.fish/products/payara-micro/)もある|
|[WildFly](https://www.wildfly.org/)|RedHat|3.2|Jakarta EEアプリケーションサーバの<br/>雄のWildFlyだが、MicroProfile対応は<br/>同社のQuarkusに絞ったのかと思わせる<br/>かのよう近年WildFlyとしての対応は消極的<br/>に見える|
|[Helidon](https://helidon.io/docs/v2/#/about/01_overview)|Oracle|3.3|Helidonにはシンプルさに特化しているが<br/>MicroProfileには非対応のHelidon SEと<br/>MicroProfileに対応したHelidon MPの2つの<br/>エディションがある|
|[Quarkus](https://quarkus.io/)|RedHat|3.3[^9]|[GraalVM](https://www.graalvm.org/)によるnative-imageの作成にいち<br/>早く対応したことで有名。また、Quarkus<br/>の実質的なMicroProfile実装となる[SmallRye](https://smallrye.io/)<br/>自体のMicroProfileのバージョンへの追従は<br/>速く、RedHatがスポンサードしている|

[^8]: QuarkusやHelidonはフレームワークではなくライブラリだろ！な声が聞こえてきそうですが、語感が良いのでここではフレームワークと言う用語と使わせていただきます
[^9]: [公式リスト](https://wiki.eclipse.org/MicroProfile/Implementation)では3.2となっていますが、Quarkusの[公式ブログ](https://ja.quarkus.io/blog/quarkus-eclipse-microprofile-3-3/) で3.3に対応したことがアナウンスされています


### （コラム）アプリケーションサーバの実装を利用する意義って何？
アプリケーションサーバを使っているからと言って、必ずしもアプリケーションサーバが提供する実装を使わなければいけない訳ではなく、もちろんアプリケーションサーバが提供する実装以外を利用することもでき、この場合は他のOSSライブラリと同様に利用したい実装をWEB-INF/libに配置すればよいだけです。

であれば、MyFacesやEclipseLinkなどJakarta EE準拠のOSSライブラリをアプリケーションサーバが持つ実装を利用することと自分で好きな実装をWEB-INF/libに配置して利用することの違いはなにになるのでしょうか？

その違いはいくつかありますが、筆者が一番大きな違いと考えているのはサポートの有無と考えています。

アプリケーションサーバの実装を利用する場合、有償にはなりますが一般的には開発ベンダーからのサポートを期待することができます。

開発ベンダーは利用しているOSSに対し、自身が実質的な開発元になっていることやコミッターを多数雇用しているなどの強いコネクションを持っている場合が多くあります。事実、WildFlyはJPAの実装にHibernateを、そしてCDIにはWeldを採用していますが、いずれもRedHatが支援しているJBossコミュニティで開発が行われているのが分かりやすい例かと思います。

昨今の開発においてOSSを使わないことはまずあり得ないと言ってよいと思います。アプリケーションサーバから利用するOSSまでワンストップで強力なサポートを期待できることは、ミッションクリティカルなアプリケーションを開発する際には非常に大きなメリットになり得ると思います。なお、サポート範囲やサービスレベルは製品ごとに異なるので、サポートを期待される場合は製品ベンダーに確認されることをお勧めいたします。


## MicroProfileの今後
[第1回](/msa/mp/cntrn01-what-mp/)のMicroProfileの登場でも軽く触れさせていただきましたが、MicroProfileの一部であったMicroProfile ConfigはJakarta EE10に取り込まれる予定[^10]となっています。また、MicroProfile Config同様、今後Jakarta EEに取り込まれることが噂されるMicroProfile仕様もいくつかあります。

これらのことから、今後はMicroProfileの成果がJakarta EEに積極的にフィードバックされていくのではないかと思われます。

Java EE時代はJavaアプリケーションのデファクトであるSpring Frameworkの後追いや劣化版的な否めませんでしたが、もし今後は標準化団体主導で新しいアーキテクチャが切り開かれ、結果それが標準化としてデファクトになることがあればそれは健全で歓迎すべきことではないかと思います（そうなるかは別ですが・・）。

MicroProfileは1.0リリースから約6年経ちバージョンも5.0となった現在、実践でも十分に有効に使える仕様になってきていることを個人的に実感しています。Javaによる現実的で実践的なマイクロサービスアーキテクチャの未来としてこの機会をきっかけに是非MicroProfileにも注目していただければと思います。

[^10]: Specifications - Jakarta Config: <https://jakarta.ee/specifications/config/>

## 標準準拠について
多くのアプリケーションでは標準準拠がそれだけでアーキテクチャの目的となることはありません。標準準拠はあくまでも私たちがアーキテクチャ上の課題を解決する上での1つの手段でしかありません。

よって、Jakarta EEやMicroProfileなどの業界の標準仕様を採用する場合、標準準拠に準拠することで「何を得たいか」、「何を解決したいか」、そして「それは他のアーキテクチャを選択するよりも大事なことなのか」を考えることが重要となります。

Spring FrameworkではなくJava EEを採用したが、Java EEはSpring Frameworkよりも○○なので、イケてない、失敗だったなどと言ったコメントや評価をたまに見聞きしたりしますが、なぜJava EEを選択したのか実際に聞いてみると、その多くは「標準だから」です。標準を利用することは目的ではありません。Jakarta EEやMicroProfileに対してこのような残念な評価がなくなることを期待し今回は終わりにしたいと思います
