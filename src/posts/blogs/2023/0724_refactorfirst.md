---
title: RefactorFirstで暑苦しい神クラスを倒そう！
author: toshio-ogiwara
date: 2023-07-24
tags: [java]
---

大きなクラスや複雑なクラスを見つけるとリファクタリングしたくなりますよね。もし、そんなリファクタリングしたくなるようなイケてないクラスがいくつもあったら、どの順番でリファクタリングしていくのが効果的なのだろうか？と迷いますよね。そんな時に費用対効果の側面から一番効果的なクラスをレポートしてくれるRefactorFirstを紹介します。

# RefactorFirstとは
RefactorFirstはJavaの静的解析ツールの１つである[PMD](..)を使い、コードベースに存在する技術的負債となっている「神クラス」を検出し、どの神クラスを優先的にリファクタリングするべきかを費用（労力）と効果の2軸でグラフィカルにレポートしてくれるMavenプラグインの機能です。

また、このRefactorFirstが用いている優先度付けの手法は論文発表されたものに基づいたもの[^1]で、ソフトウェアエンジニアリングの観点からその有効性が実証されているものとなります。

[^1]: Nico Zazworka、Carolyn Seaman、Forrest Shull による論文[「Prioritizing Design Debt Investment Opportunities」]( https://dl.acm.org/doi/10.1145/1985362.1985372)に基づいています。この論文に基づくプレゼンテーションは、[こちら]( https://resources.sei.cmu.edu/asset_files/Presentation/2011_017_001_516911.pdf)からから入手できます。

ですので、なんとなく「一番はコレだー！」というモノではなく、プラグイン作者のオレオレ理論ではなく、その内部では今まで有効性が認められてきた様々なメトリクスが使われています。冒頭の説明で用いた「神クラス」も複数のメトリクスの結果から識別されています。

今回はRefactorFirstのレポートをもとに、どのようなメトリクスからそのような結果になっているのかについて、堅苦しい理論ではなく、その意味を平易に説明してきたいと思います。

ということでまずは動かしてみましょう！

:::column:神クラスとは
:::

# まずは動かしてみる
RefactorFirstのリポジトリには神クラスが複数個あり、良い感じのレポートが出力されるサンプルが付いているため、このサンプルをもとに説明してきます。

まずはリポジトリをチェックアウトし、リポジトリの直下に移動しましょう。
```shell
git clone https://github.com/jimbethancourt/RefactorFirst.git
cd RefactorFirst
```

次にRefactorFirstを実行します。実行するMavenコマンドは次のとおりです。
```shell
mvn org.hjug.refactorfirst.plugin:refactor-first-maven-plugin:0.4.0:report
```

実行が成功するとリポジトリ直下に`/target/site/refactor-first-report.html`ができています。これがRefactorFirstのレポートになります。

:::info: RefactorFirstのリポジトリ構成
RefactorFirstのリポジトリはMavenのマルチモジュールによるモノレポ構成になっています。なお`/target/site/refactor-first-report.html`に出力されるレポートに登場するクラスはリポジトリ直下の`test-resources`プロジェクトのクラスになります。またMavenコマンドを実行するとトッププロジェクトの`RefactorFirst`だけが実行され、他のサブプロジェクトはすべてSKIPされますが実行結果としては問題ありません。
:::

# グラフの見方
`refactor-first-report.html`をダブルクリックしてブラウザで開くと次のグラフが現れます。
グラフの中をドラックすることで中止を移動することもできますし、マウスホイールを動かすことでグラフを拡大／縮小することもできます。

[図]

大きさの違う円が5つプロットされていますが、これがリファクタリング対象として抽出された神クラスになります。この神クラスはPMDのGod Class Ruleに掛かったクラスになります。

これは言い方を変えるとRefactorFirst はPMDのGod Class Ruleに掛からなかったクラスはリファクタリング対象外としてレポートの対象にしません。実際、`test-resources`プロジェクトには6つのクラスがありますが、その中の`Attributes`クラスはGod Class Ruleには掛からなかったため、グラフには出てきていません（コードを見ればリファクタリングの余地なしということは直ぐ分かります）。

グラフの見方としてまず本題の1番優先してリファクタリングすべきクラスはグラフの真ん中にある緑色の`AttributeHandlerJavaEleven.java`なります。

RefactorFirstはグラフ上、優先度を色によって識別できるようにしています。そしてその色はグラフ上部の`Priority Ranking for Refactoring God Classes - Start with Priority 1`のグラデーションで表されているように緑の優先度1から始まり、右側の赤になるほど優先度が低くなります。

ですので、グラフ上優先度が一番低いのは真ん中辺りの小さい赤丸の`AttributeHandler2.java`になります（マウスカーソルをグラフ上の円に持っていくとポップアップで詳細が表示されます）。

この優先度の高低はどのような考えに基づいているかというと、優先度高のものは「リファクタリングの手間が掛からず、効果が高いもの」、対して優先度低は「リファクタリングの手間が掛かり、効果も低いもの」となります。

では、優先度はどのように決めているのか？ですが、これは横軸の労力(Effort)と縦軸の変化傾向(Change Proneness)から導出しています。ということで次からは縦軸と横軸の内容とその見方を見ていきます。

# 横軸の労力(Effort)とは
詳しいことは後回しにして横軸の意味をザックリいうと、横軸はリファクタリングに掛かる労力で、右に行けば行くほど労力が掛かる、つまり強敵クラスという意味になります。そして、横軸の数値はリファクタリング対象として抽出された神クラスを労力が掛からない順にランキングした値となります。

したがって、リファクタリング労力が掛からないランキング1位は`AttributeHandlerAndSorter.java`で、最下位は5位の`Console.java`となります。

## PMDによる神クラスの判定
PMDは神クラスを次の3つのメトリクスをもとに判定しています。
- 複雑度
  - メソッドの数や制御構文が多ければ多いほどプログラムは複雑であるとした循環的複雑度(Cyclomatic complexity)
- 結合度
  - 他のクラスのオブジェクトの属性を参照している数。他への依存が多ければ多いほど他からの変更影響を受けやすいという考えに基づいている
- 凝集度
  - クラス内の同じフィールドを参照しているメソッドの数。この数が多ければ多いほど、クラスに関係するもの（フィールド）と扱うもの（メソッド）がまとまっているとみなせる

PMDはそれぞれのクラスごとに上述した3つのメトリクスを取得し、そのすべてが閾値を超えているものを「神クラス」と判定しています。PMDが取得しているメトリクスの詳細や閾値は[こちら](https://maku77.github.io/memo/god-class.html)のサイトで分かりやすく説明されています。

## 労力(Effort)のランキング付け
ドキュメントに記載はないですが、コードを見るとRefactorFirstはこのPMDが神クラス判定に使ったメトリクスをもとに労力(Effort)のランク付けを行っています。複雑度、結合度、凝集度のそれぞれごとに数値が低い順にランキングをつけ、その3つを足し合わせた数値を神クラスの労力(Effort)として最終的にランキングを付けています。

- 労力(Effort)のランキング付けの例
  
||複雑度|結合度|凝集度|合計|労力(Effort)|
|--|:---:|:---:|:---:|:---:|:---:|
|Aクラス|2位|3位|1位|6|2位|
|Bクラス|3位|2位|2位|7|3位|
|Cクラス|1位|1位|3位|5|1位|

※数値的に良い方が順位が上

# 縦軸の変化傾向(Change Proneness)とは
縦軸の変化傾向の意味は不具合が発生する確率になります。Change Pronenessの直訳の変化傾向という単語から飛躍がありますが、これは「リリース前に何度も変更されるコードは、同じ期間内であまり変更されないコードよりもリリース後の欠陥が多くなる可能性が高い」というWindows Server 2003の開発時に行われた研究結果[^2]をもとにしています。
[^2]: [Use of relative code churn measures to predict system defect density](https://ieeexplore.ieee.org/document/1553571)

こちらもドキュメントに記載はないですが、コードを見るとRefactorFirstはこの「リリース前に行われた変更」を「変化傾向」として捉え、この変化傾向を数値化するため、Gitのcommitログから次の2つを取得しています。
- 該当ファイルが作成されてからの総コミット数（総コミット数）
- 該当ファイルの変更が含まれるコミット数（変更コミット数）

そしてこの2つの数値を`変更コミット数 / 総コミット数`したものを変化傾向の値としています。つまり、RefactorFirstにおける変化傾向とは「コミットに該当クラスの変更が含まれる確率」を意味し、数値が高いクラスほど変更が頻繁に発生していると考えることができます。

また、この変化傾向が少ない順にランキング付けした値が縦軸の変化傾向(Change Proneness)数値となっています。

# まとめ
RefactorFirstは最終的に費用対効果から見たリファクタリングすべき優先度を、「変化傾向(Change Proneness)の順位」から「労力(Effort)の順位」を引いた値が大きい順にランキング付けして導出しています。

また、変化傾向(Change Proneness)と労力(Effort)を数値化することで次のことが判断できます。
- 変更頻度が多いものは不具合の確立が高いため改善する価値がより高い（効果が大きい）
- 複雑度と結合度が低く、凝集度が高いクラスほど改善を行いやすい（コストが掛からない）

RefactorFirstはコードベースをもとにソフトウェアエンジニアリングの観点から、リファクタリングを行った場合に、掛かるコストが少なく、効果が大きいクラスを見つけてくれるツールとなります。

ソフトウェアエンジニアリングは「あるプロジェクト」における経験則を定型化、数値化した側面もあるため、常にそれが成り立つ絶対といえるものではありません（個人の感想です）。このため、RefactorFirstが常に正しく、これに従うべきというスタンスではありませんが、一方で規模の大きなプロジェクトではすべてを人間の目で細かく確認することは非現実的と考えています。このような時にRefactorFirstのようなツールで個別に確認しなければならない対象を手早く効果的に選別するにはとても有効です。是非、プロジェクトで活用してみていただければと思います。




