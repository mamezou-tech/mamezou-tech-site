---
title: 組込みLinux環境のブートについて
author: kazuya-iwamoto
date: 2024-05-01
tags: [組込み, linux]
---

## はじめに

この記事をご覧になっている皆さん（ソフトウェア屋さんを対象としています）はPCプラットフォームについては慣れているかと思います。
そういった方でもロボットに限らず組込みプラットフォームというものに触れて戸惑った経験がある方も多いのではないでしょうか。

その戸惑いはどういう構成になっていてどういう仕掛けになっていて...という理解が足りていない事からきていると思われます。
やはり得たいの知れないものを触るのは怖いものです。
おっかなびっくり？触っている人もいるのではないでしょうか。

その中でもこのシステムはどう起動しているんだろう？という疑問を持っている人も多いかと思います。
ここをミスるとシステムが起動しなくなる部分ですのであえて触れない様にしている人もいるかもしれません。

しかし、このシステム起動を理解すると起動に必要な構成を理解出来る＝システムの全体像を理解出来る様になります。
また万が一起動しなくなった場合でも復旧する際のイメージが沸くようになります。
何かあっても復旧させることが出来ると思える事は大きいです。
おっかなびっくり触ることもなくなります。
ここをクリアすればそのシステムを極めたも同然です（個人差はあります）。

ここではそういった方々向けに組込みプラットフォーム、中でも組込みLinuxのソフトウェア環境について事例をこれから前編、後編にわたり紹介していきたいと思います。



## 組込みLinuxプラットフォーム

さて、実際に組込みLinuxの起動を見ていきましょう。  
あなたの手元に組込みLinuxのボードがあるとします。  
　LinuxはSDCARDから起動すると聞きました。  
　確かにWindowsPCから覗くとSDCARDの中に u-boot, kernel というファイルがありました。  
　ルートファイルシステムも入っていると聞きましたがWindowsPCでSDCARDを覗いても見えない様です。  
これらでシステムが起動するとの事なのですが...。

これらのファイルはどういう役割があるのでしょうか？
そして果たして"見えている"これらが全てなのでしょうか？

以降、その役割について触れていきます。

## その構成要素

組込みLinuxプラットフォームのソフトウェアは大きく分けると以下の3つから構成されています。
- ブートローダ
- Linuxカーネル
- ルートファイルシステム

大枠の説明をまず行っておきます。
- ブートローダ  
CPUが最初に実行し始めるプログラムであり、いろんな初期化を行いLinuxカーネルが動き始める準備をしLinuxカーネルを起動させます。
Windows PCではBIOSとかUEFIとか言われたりする部分となります。

- Linuxカーネル  
OSの中心となるファイルの事です。
Windows PCでは1つのファイルでは表現しづらいかもしれませんが、Windowsフォルダ以下にあるntoskrnl.exeとなるでしょうか。
（普段意識するファイルではないですが、ブルースクリーンが発生した場合に発生元として見る事があります）

- ルートファイルシステム  
Windows PCでは通常 C:ドライブ（Windows起動ドライブ）相当となりますが、カーネルを中心としてOSを構成するファイル全体となります。

本記事では中でもこのブートローダを中心にシステムが起動（ブート）していく過程について自分が経験した事例を紹介していきます。


## CPUが動き出すという事

"ブートローダ"を中心に見ていくと書きましたが、そもそも"ブート"とはどういう事でしょうか？
色々な説明がされる事もあるかと思いますが、ここではCPUが動き出しシステムに必要な初期化を行いOSを起動する過程とします。
この"CPUが動き出す"きっかけがいわゆるリセットと言われるものです。

CPUがリセットとなった時（正確にはリセットが解除された時）にどういう挙動をとるかは各CPUにより決まっています。
大別すると以下の２種類となります。
- パターン１．特定アドレスからプログラムの実行を開始する（固定アドレス）
- パターン２．特定アドレスに格納されたアドレスからプログラムの実行を開始する（可変アドレス）

余り意識した事がないかもしれませんので、以下実例を挙げていきます。
また、リセットについてはCPUの機能の内、例外と言われる処理の一種として説明される事が多いです。（例外処理というもの自体については今回は触れません）
例外処理は一覧として例外テーブル、ベクタテーブルと言われるもので管理される事が多いのですが、リセットの扱いは以下の場合があり得ます。
- 例外テーブルの内の一種（他の例外と一緒に並んでいる）  
- リセットだけ別扱い（例外テーブルとは別）  

CPUドキュメントを読む際にはそういう扱いがあり得るんだと頭の片隅に置きながら読んで頂ければと思います。

以下CPUによる実例を挙げていきますが一番一般的と思われる例を挙げています。組込み系バージョンとしてカスタマイズが入り異なっている場合もありますのでご了承ください。

- 68系 [^1]  
今となっては知る人はいないかもしれませんが、かつては86系と天下を二分していました。
パターン２となります。  
・アドレス：(ベースアドレス) + 0x00000004 に書かれたアドレス  
68000の例ではベースアドレス指定がありません。そのまま0x0000000番地を先頭として例外テーブルが並んでいるうちの1つとなります。

- 86系 [^2]  
WindowsやUbuntu等Linuxで普段お世話になっているかと思います。
普段余り意識しないかもしれませんが、パターン１となります。  
・アドレス：0xfffffff0  
リセットだけが別扱いで他の例外はIDTというRAM上の例外（ディスクリプタ）テーブルとなります。

- MIPS系 [^3]  
一時（いっとき）はコンシューマゲーム系を制覇していたCPUですが、パターン１となります。  
・アドレス：0xbfc00000  
組込み系での例を見かけた事もありますが、この原則に従ってそうでした。  
リセットのアドレスに限らずMIPS系は特徴的なメモリマップ（同じ物理アドレスを複数の論理アドレスでマップ）を持っていますのでそれを眺めるだけでも楽しめます。  
かつては日本が強かった分野ですので検索するとドキュメント実例が発掘出来るかと思います。（NEC：VR系、東芝：TX系等）

- PowerPC系 [^4]  
一時（いっとき）はコンシューマゲーム系を制覇していたCPUですが（その２）、有名な日本語訳PowerPCドキュメントでの例でパターン１となります。  
・アドレス：(ベースアドレス) + 0x100  
某ゲーム機のCPUドキュメントでも同様だったと記憶しています。  
他の例外開始アドレスもオフセットアドレス 0x200, 0x300...と並ぶ内の一種です。  
これ以外の組込み用での例を見た事がありますが、それではパターン２となっていました。  
他の例外のオフセットアドレスも元のPowerPCでは固定アドレス（0x200, 0x300等の値）となっている部分もこの組込み系の例では専用レジスタで設定出来る様になっていました。
ただそのレジスタ設定値も0x200, 0x300等と元のPowerPCを踏襲した値ではありました。

- ARM(32bit)系 [^5]  
今となってはトラディショナルですが、パターン１となります。  
・アドレス：(ベースアドレス) + 0x00000000  
他の例外合わせたテーブルとなっています。特徴的なのはその各例外用の領域が4Byteずつしかなく、実質ジャンプ命令しかおけない事です（実質パターン２）。
テーブル末尾のFIQ(Fast Interrupt Request)だけはその後にも命令を続けられるのでジャンプ命令が省けるという（流石はFIQ）特典がある事になります。  
いにしえのARMv4のARM7TDMIの例ではベースアドレス指定はなかったかと思いますが、これより後では High vector や VBAR という仕組みでベースアドレスが選択出来る場合もあります。
この場合でもこの例外テーブルの構成自体は同じです。

- ARM(64bit)系 [^6]  
32bit時代からがらっと変わり ARMv8のCA53あたりの例ですがパターン２となります。特定レジスタにリセットアドレスが格納されています  
・RVBAR_ELx（Reset Vector Base Address）  
格納されるアドレス自体はSoC固有の値となります。  
　This field has an IMPLEMENTATION DEFINED value.  
また他の例外テーブルとは扱いが異なります。

- CortexM系 [^7]  
CortexM4の例としてパターン２となります。  
・アドレス：(ベースアドレス) + 0x04 に書かれたアドレス  
NVICという割込みコントローラが使用された時の例ですが、これも他の例外含めたアドレスのテーブルとなっています。
私が見た例は ベースアドレス が 0 で、0x00000000番地から例外テーブルが並んでる例でした。

- SH系 [^8]  
某コンシューマゲーム機に搭載されていた事でも有名なSH4(7750R)の例ではパターン１となります。  
・アドレス：0xa0000000  
MIPS系と同様に同じ物理アドレスを複数の論理アドレスでマップする構成になっています。

- RX系 [^9]  
Rx230の例でパターン２となります。  
・アドレス：0xfffffffc に書かれたアドレス  
他の例外テーブルとは扱いが異なります。

- RISC-V [^10]  
実装依存となります。  
　The pc is set to an implementation-defined reset vector.  
自分が経験した場合では特定レジスタに設定したアドレスからのスタートになっていました（パターン２）。

## おわりに
今回の前編ではそもそもブートとは？というところでCPUが動き出す部分を紹介しました。
次回の後編ではブートローダ本編を紹介します。


## 参考文献

[^1]: 68030ユーザーズマニュアル, MOTOROLA  
[^2]: Intel 64 and IA-32 Architectures Software Developer Manuals, intel  
[^3]: MIPSプロセッサ入門, 中上一史他, CQ出版社  
[^4]: 32ビット PowerPC アーキテクチャ プログラミング環境, freescale  
[^5]: ARM7TDMI Technical Reference Manual, ARM Architecture   Reference manual, ARM  
[^6]: Arm Architecture Reference Manual for A-profile   architecture, ARM  
[^7]: Armv7-M Architecture Reference manual, Cortex-M4 Devices, ARM  
[^8]: SH7750、SH7750S、SH7750R グループ ユーザーズマニュアル ハードウェア編, ルネサスエレクトロニクス  
[^9]: RX230グループ、RX231グループ ユーザーズマニュアル ハードウェア編, ルネサスエレクトロニクス  
[^10]: RISC-V Volume 2, Privileged Specification, RISC-V International  

