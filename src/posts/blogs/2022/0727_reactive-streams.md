---
title: リアクティブストリーム (Reactive Streams)
author: shigeki-shoji
date: 2022-07-27
tags: ["reactive-streams"]
---

[リアクティブ宣言](https://www.reactivemanifesto.org/ja) に次のように書かれています。

>今日のアプリケーションは、モバイル機器から数千のマルチコアプロセッサによって動作するクラウドベースのクラスタまで、あらゆる機器上に配備される。ユーザはミリ秒の応答時間と 100% の稼働率を期待する。データはペタバイト単位で測定される。

[リアクティブストリーム (Reactive Streams)](https://www.reactive-streams.org/) は、常時流れてくる大量のイベントを漏れなく処理するためにバックプレッシャーで流量を制御しながらハイパフォーマンスなノンブロッキング非同期処理フローを実現します。

最初に単純なフローを示します。

![単純なフロー](/img/blogs/2022/0727_reactivestreams-01.png)

バックプレッシャーがない場合、Kafka でサブスクライブしたイベントは次々に「処理」に push されます。
イベント発行の速度が「処理」の速度より速い場合には、バッファが溢れ、取りこぼしが発生します。

リアクティブストリームのバックプレッシャーの場合、「処理」自身がイベントを Source から取得します。このケースでは前述と同様「処理」が遅い場合には、Kafka からサブスクライブされていないイベントが蓄積され、やがてイベントの有効期限により Kafka から削除され取りこぼしが発生することになります。

結果だけ見れば同じだと思われるかもしれません。しかし、前者の場合取りこぼしたイベントの再処理は手動による困難な作業となりますが、後者では Kafka のイベント数を監視し処理数を超えたイベント発生を検出でき、フローの処理を水平スケールして残イベント数を減らす等の対処の時間稼ぎが可能です。

また残イベント数の増加をトリガーにオートスケールも可能です。

さらに並列度を予め高めておくことも可能です。

![並列度を高めたフロー](/img/blogs/2022/0727_reactivestreams-02.png)

リアクティブストリームは1つのイベントをブロードキャストして異なる処理を並行して実行させ、その処理結果をマージできます。これは、EIPs の [Publish/Subscribe channel](https://www.enterpriseintegrationpatterns.com/PublishSubscribeChannel.html) に似ています。

![Fan-Out/In](/img/blogs/2022/0727_reactivestreams-03.png)

Fan-Out された処理は同時に完了しません。データベース更新処理よりも Email 送信には時間がかかるかもしれません。しかし、バックプレッシャーがあることで Fan-In はそれらの処理結果を容易にマージできます。

Fan-In によって並列化されたすべての処理結果が成功だった場合のステータス変更やいずれかが失敗だった場合の補償トランザクションの実行を可能にします。
