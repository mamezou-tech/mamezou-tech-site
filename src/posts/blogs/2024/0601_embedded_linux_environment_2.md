---
title: 組込みLinux環境のブートについて
author: kazuya-iwamoto
date: 2024-05-01
tags: [組込み, linux]
---

## はじめに

前編ではCPUが動き出すところのお話をしました。  
今回の後編では実際にブートローダについての実例を紹介していきます。

## 1stブートローダの格納場所

前回の様に特定のアドレスからCPUはプログラムの実行を開始する事になります。  
そのためそのアドレスにブートローダを格納する事になります。（表題に"1st"という名前がついている理由については後述します）

その場合の格納場所はプログラムが直接実行出来る、かつ不揮発性領域が必要となります。
そのため通常はプログラムROM（いわゆるNOR型ROM）に格納されています。
（例外テーブルを持つ場合はそれも一緒にROMに格納されています）

場合によってはSoC作成時に一緒に焼き込まれているROMの場合もあります（書換え不可）
Mask ROMと呼ばれていた例を見た事もありますが、例えばJetson TX1だと以下の表現で書かれています。  
BootROM The Jetson TX1 BootROM (BR) is hard-wired in the processor. It initializes the Boot Media and loads bootloaders and firmware from the Boot Media.

CPUがリセット時には特定アドレスからプログラムの実行を開始する事しか行えません。
SDCARD、SATA、USBメディア等は直に"特定アドレスからプログラムを実行"という事が行えないデバイスなため使用できません。  
（そのデバイスを読むためのプログラムをデバイスから読む事が必要・・・といった事態となります）   
これらデバイスからプログラムを実行する場合はデバイスからプログラムをRAMに読込み"RAM上の"プログラムを実行するという形が必須となります。

これらROM種別というとNOR型、NAND型という用語が登場する事が多いです。
ですが、  
　　ROMが NOR or NAND からどう構成されている／どう配線されている  
というイメージが出来る人は正直少ないのではないでしょうか。
ソフトウェア屋さんとしては以下が意識出来ていれば大丈夫かと思います。  
- NOR型ROM ：ROMコントローラのアドレスだけでなくそのROMの中身もアドレス経由で読む事が出来る（＝なので直接プログラムが実行出来る）  
- NAND型ROM：ROMコントローラのアドレスだけしか見えず、ROMの中身を読むにはその見えるアドレスからコントローラを叩いて読みださないといけない

なのでもしNAND型ROM上のプログラムを実行したい場合はROMコントローラを叩いてRAM上にプログラムを読込んでそれを実行という事になる訳です。
以上の理由から1stブートローダにNOR型ROMが必要な理由かがわかるかと思います。

## ブートの過程

ここからはブートの過程を細かく見ていきます。

前述のブートローダがNOR-ROMに格納云々と書きましたが、  
あれ？  
- SDCARD上にu-bootってブートローダらしきファイルがありますよ？  
- SDCARDブート、USBブートって言葉がありません？  

と思われた方もおられるかもしれません。

それらSDCARD、USBメディア上に格納されたブートローダはNOR型ROM上に格納された前述のブートローダから実行された2段階目（以降）のブートローダとなります。
これら見える場所にある2段階目（以降）のブートローダの事を唯一のブートローダと思われている場合もあるかもしれません。

実際1段階目のブートローダは公開されていない（ユーザが触ることができない）場合がほとんどかと思います（むしろ公開されているのは見た事がない）
通常は書換える方法も公開されていません。前述の様に書換え自体も出来ないかもしれません。

この1段階目のブートローダが最低限の初期化を行い、対応した限られたメディアから2段階目のブートローダを読みます。
それらメディアからどこかのRAMに読込み、RAM上で実行されます。

そしてこの2段階目のブートローダがより広い初期化を行い、対応したより広いメディアから更に次のブートローダもしくはkernelを読み込む・・・といった流れで出来る事を増やしていきます。
またセキュアなシステムの場合はこの流れの中でセキュリティ関係の処理（署名確認、復号化等）も行われます。

こうして最終的な目的のkernel起動が行われる事となります。

初期化の範囲について同様な事はプログラムを実行するのに必要なRAMにも言えます。
プログラム実行についてプログラム自身はROMから直接実行するにしても変数領域にはROMではなくRAMが必要となります。
一般的にRAMと聞いて思い浮かべるであろうDRAMは（結構面倒な）初期化を行わないと使用できません。このDRAM初期化を行うプログラムをDRAMを用いて実行する訳にはいきません。  
（RAMを初期化するためのプログラムにRAMが必要・・・といった事態となります）

そのためメインで使用するDRAM以外のブート時に使用出来る（最低限のサイズの）RAMが必要となります。
このあたりの仕組みは各SoC固有となるのですが、ブート用の少量のSRAMを搭載している、GPUのVBRAMを使用する等の事例を見かけた事があります。
最近のSoCはヘテロジニアスなCPUコア構成も多いのでSoCのサブコアから起動、DRAM含めいろんな初期化を行った上でようやくKernelが動作するメインコアを起動といった例もあります。  
（例えばRaspberry-PIのブートについても検索されると興味深い例が見つかるかと思います）

この様に
- このシステムはそもそもどこからブートしているんだろう？
- （見える場所にある）このブートローダは誰が読んでいるんだろう？
- またそのブートローダは次にどこからLinuxカーネル、ルートファイルシステムを読むんだろう？
- ユーザに公開されているのはどこからだろう？
- どの段階でどこまでの事が行えるのだろう？
といった事を考えながらシステムを見ると理解が深まると思います。

以上の様な多段階ブートを行う場合の典型的な例をあげておきます。


|ブートローダ種別|公開|形態|格納場所例|後段への役割|
|:--|:--|:--|:--|:--|
|1stブートローダ|非公開|独自|NOR型ROM、hard-wired|2ndブートローダを読み出す|
|2ndブートローダ|公開|u-boot|SDCARD、SPI-ROM、USBメディア他|Kernelを読み出す|

なお、u-bootというブートローダを見かける場合が多い理由は以下が考えられます（実際便利です）
- 幅広いデバイスを読む事が出来る（オープンソースな事もありデバイスドライバが充実している）
- それらデバイスの動作確認が行える（ブートローダというよりむしろ）、テストアプリケーションとしても使用出来る
- Linuxカーネルをロードするのに便利な機能がある
- 1段階目のブートローダはユーザに触らせず非公開にしても、このu-boot（オープンソース）以降を公開し自由にユーザに触ってもらう形に出来る

## 2ndブートローダ以降の格納場所

1stブートローダの置き場所にはできませんが、2ndブートローダ以降Linuxカーネル含め置き場所として以下があり得ます。
- SPI-ROM
- SDCARD
- eMMC
- SATA
- USB
- PCIe系

前述の通りこれらからは直接プログラムの実行には使用できませんので、これらからプログラムが一度RAM上に読み込まれた上で実行されます。

- SDCARD  
メディア自体はスマートフォン等でもお馴染みのものです。  
  - その1  
SDCARD上でファイルという形で見える場合です。
多いのはFAT系ファイルシステムが使用されている場合で、この場合はWindowsPCに差すとWindows上でも確認できて安心感があります。
WindowsPC上からエクスプローラで書込みが行えます。

  - その2  
同じくSDCARDを使用していてもファイルとして見えないパターンがあります。
FAT系ファイルシステム無しでSDCARDに直接書き込まれている場合です。
この場合は例えばWindowsPC上に差しても見て確認が行えません（Windows上でドライブとして見えません）。
また書込む際にも例えばWindows上では専用ツールが必要となります。
（Linux上では良くddコマンドが使用されます）
この場合はSDCARD上に2ndブートローダを用意する側の利便性は下がりますが、これを読む1stブートローダの作りが簡便になるというメリットがあります。
（SDCARDコントローラを叩くだけで良く、ファイルシステムを理解する必要がない）  
  
  これらSDCARDの場合の例ですが、特に開発初期の頃にありがちなのがSDCARD上に見えているブートローダ、もしくはカーネルを書き換えてたのに反映されない？と思ったら実は上記その2のパターンだったという事が起こり得ます。
  （そもそもSDCARD以外だったという事も）  
  見えているものだけで判断せずそのシステムそもそもの理解が必須となります。

- SPI-ROM  
これも特に2ndブートローダの置き場所としてよく見かけます。
通常基板から取り外せるものではないのでその基板上でSPI-ROMコントローラを叩いて書込む必要があります。  
（細かくはSPI-ROMの中身も直接アドレッシング出来るモードを持つコントローラ例を見た事がありますが、ブートROM目的ではなくOSも持たない組込み系での（他デバイスでブートした後での）アプリケーションROM目的のものでした）

- eMMC  
イメージ的には取り外せないSDCARDの様なものですが、格納パターンとしてもSDCARDのその1、その2がありえます。

- SATAメディア  
よくSSD、HDDとして見かけるものですが、これもSDCARDに準じます。
SSD、HDDと聞くとx86 Linuxで見慣れた形の様に見えるかもしれませんが、それとはブートローダの構成は別になっている場合が多いと思います。
取り外しは可能としても取り外す際に工具が必要だったり奥まった場所にあったりでSDCARDよりは扱いが面倒な場合があります。
（ブートローダ、Kernelが起動しなくなる度に取り外して別システムで復旧しないといけなく面倒だった経験があります）

## （おまけ）ブート時以外のブートローダ、ファームウェア

ブートローダと言えばブートする時に用いられ、OSが起動された後は用済みで使用RAMも解放される場合が多いのですが、OSが起動した後も使用される（RAM上に常駐する）場合もあります。
ユーザプロセスが上位のOSに仕事を依頼する（System Call）場合がある様に、OSが上位の"何か"に仕事を依頼する場合にその"何か"にあたるものとなります。  
内容としてはOSが依頼するレベルの管理、例えばプラットフォーム全体の管理（電源、クロック等）があります。
このサービスをOS（Linux kernel等）から分離する事で、他OSにした場合でも使用出来る、Kernelは公開でもこの部分は分離して非公開に出来る、等のメリットが考えられます。
（どういう処理を行っているのか知りたくてkernelソースを読んでいったら最後 HyperVisor Call, Secure Monitor Call等をして上位に飛んでいるのがわかっただけだった...というオチになったりする場合があります）

## おわりに
以上組込みLinuxがブートする際の事例を紹介してきました。
皆さんの今まさに目の前にある組込みプラットフォームの理解の一助、楽しめるネタの一つになれば幸いです。

