---
title: ヘキサゴナルアーキテクチャでモヤっとしていた4つの疑問を整理してみた
author: toshio-ogiwara
date: 2025-12-08
tags: [ソフトウェア設計, advent2025]
image: true
---

これは[豆蔵デベロッパーサイトアドベントカレンダー2025](/events/advent-calendar/2025/)第6日目の記事です。


ヘキサゴナルアーキテクチャ（Ports & Adapters）って、なんとなくわかった気はするけど、どこか腑に落ちないところありませんか？私の場合はだいたいこの4点でした。

- 「依存は外側 → 内側」と言うけれど、**入力ポートとその実装で依存が逆向きに見える**のはなぜ？それいいの？
- **入力のアダプタは port を実装していない**のに**出力のアダプタだけ port を実装している**のはなにか気持ち悪い
- そもそも、**オニオンアーキテクチャと何が違うの？**

この記事では、これらのモヤモヤを整理したときのメモをSpring Boot の簡単な TODO アプリを例にしつつまとめてみます。

## 説明の例に使うヘキサゴナル構成（TODO アプリ）

説明はパッケージ構造が次のようになっている「教科書的ヘキサゴナル」な Spring Boot アプリを例に行います。

```text
com.example.todohex
├─ TodoHexApplication        … @SpringBootApplication
│
├─ domain                    … ドメインモデル（純粋Java）
│   └─ Task.java
│
├─ application
│   ├─ port
│   │   ├─ in                … 入力ポート（UseCase IF）
│   │   │   ├─ CreateTaskUseCase.java
│   │   │   └─ GetTaskUseCase.java
│   │   └─ out               … 出力ポート（Repo/Gateway IF）
│   │       ├─ SaveTaskPort.java
│   │       └─ LoadTaskPort.java
│   └─ service               … ユースケース実装
│       └─ TaskService.java
│
├─ adapter
│   ├─ in
│   │   └─ web                … RESTアダプタ（入力側）
│   │       ├─ TaskController.java
│   │       ├─ TaskRequest.java
│   │       └─ TaskResponse.java
│   └─ out
│       └─ persistence        … 永続化アダプタ（出力側）
│           ├─ TaskEntity.java
│           ├─ SpringDataTaskRepository.java
│           └─ TaskPersistenceAdapter.java
└─ ...
````

## 1. 依存が逆になってるところがあるけどいいの？

どこが「逆向きに見える」かですが、UseCase と Service の依存関係(赤線)をみると次のように依存が右から左になっています。

![01](/img/blogs/2025/1208_hexagonal_four_questions/01_port-in.drawio.svg)

一方でヘキサゴナルアーキテクチャの世の解説では「モジュールの依存は外側 → 内側」といった説明もたくさん出てきます。ここで「えっ、`port` と `service` の依存関係って外側から内側の反対に向いているけどいいの？」という違和感が出てくるわけです。

そこで、いったん原典に立ち戻りヘキサゴナルアーキテクチャの提唱者であるアリスター・コバーン自身は何と言っているか振り返ると、アリスター・コバーンの[元記事][1]を読むと、彼が言っているのは大ざっぱにいうと以下のようなことです。

> * アプリケーションは **Port** を通して外部と会話する
> * その **Port** のプロトコルは「アプリケーションの API という形をとる」

ここでいう「API」は、メソッド呼び出しでもいいし, HTTP でも, メッセージングのプロトコルでもなんでも良い、というかなり抽象的なレベルの話をしていて、少なくとも原典では、

* 「入力ポートを **インタフェースと実装クラス** に分けろ」
* 「モジュールの依存矢印は **必ず外→内に向けろ**」

といった Java 的な「お作法レベル」のことは原典では言っていません。また、最近の彼の[スライド版][2]でも型付き言語向けに

> * “required interface” を宣言しよう
> * Port の宣言用フォルダを用意しよう

くらいはいっていますが、**依存の矢印ルールそのものには踏み込んでいません。**

:::column: 結論：依存を外側から内側へは単なる都市伝説
アリスター・コバーンは依存方法についてはなにも言っていません。むしろ、ポートにはインタフェースを出せといっているので、ポートとその実装間で依存が逆になるのは自然です。この話しは「依存は外側のリングから内側のリングへだけ許可」と明確にいっているクリーンアーキテクチャと同じコンテキストでヘキサゴナルアーキテクチャが語られることから生まれた都市伝説と思われます。
ただ、`port.in` と `service` を 1 つの「アプリケーション・コアの塊」として見てしまえば、`adapter.in` → `（port.in＋service）` → `domain` という「外→内→外」の構図となるので、いわゆる、クリーンアーキテクチャの1種とみても問題ないとも思います
:::

## 2. アダプタってポートをするのものなの？

次のモヤモヤはこれです。

* in 側の adapter（Controller 等）は port.in を実装していない
* out 側の adapter（DB や外部API）は port.out を実装している

言葉だけではわかりづらいのでこれを図で表すと次のようになっています。

![02](/img/blogs/2025/1208_hexagonal_four_questions/02_adapter.drawio.svg)

ポートを実装したりしなかったり、そもそも左右で対称じゃなく、なんとなく気持ち悪いですよね。というか正直これってホントにあってるの？と思ったりしたのは私だけでしょうか？

疑問があったら[原典][1]ということでまたアリスター・コバーンがなんといっているかみてみましょう。
彼は Hexagonal を Ports & Adapters とも呼びますが、ここでいう Port と Adapter は「役割の名前」です。

* Port：
  * 「何のための会話か」を表す**論理的な接点**

* Adapter：

  * その Port を、特定の技術（HTTP / CLI / DB / メール / ファイル…）に**接続する変換器**

そして彼の[スライド][2]では、Port を

* **Driving Ports（アプリケーションを“駆動する”側）**
* **Driven Ports（アプリケーションが“駆動される側”に依頼する側）**

に分けて説明しています。

この観点で見ると、

* **Driving Port 側**
  * Adapter（UI / REST / Batch …）は「Port の定義に従ってコールする**クライアント**」
* **Driven Port 側**
  * Adapter（DB / メール / 外部API …）は「Port の定義を満たして処理する**サーバ**」

になるため、

* in 側の adapter が port を 実装していない
* out adapter が port を 実装 している

という**非対称さは実は自然**なものとなります。

:::column: 結論：アダプタとポートは役割名で構文パターンのことではない
Port / Adapter という名前は「入力＝implements、出力＝implements」という構文パターンのことではなく、**「会話の目的を表す窓口」と「外界との変換器」という役割を指している**だけ。そう捉えると、実装アリナシの非対称さはそこまで気にならなくなります。
:::

## 3. オニオンアーキテクチャと何が違うの？

最後のモヤモヤはこれです。
> 結局、ヘキサゴナルとオニオンって、何がどう違うの？

では、その違いが分かるようにそれぞれの全体構造をみてみたいと思います。

### まずオニオンアーキテクチャ

オニオンアーキテクチャをラフに描くと次のような感じになります。

![03](/img/blogs/2025/1208_hexagonal_four_questions/03_onion.drawio.svg)

<br>

オニオンアーキテクチャの主眼は
* ドメインを中心に同心円状に層を作り
* 依存は外側 → 内側になるようにして
* **ドメインを守る**

といったところになります。

### 次にヘキサゴナルの構造

対してヘキサゴナル（Ports & Adapters）は、**境界（Port）にフォーカスしたアーキテクチャ**といえます。

![04](/img/blogs/2025/1208_hexagonal_four_questions/04_hexagonal.drawio.svg)

こうして2つを並べてみると、ヘキサゴナルアーキテクチャは構造的にオニオンアーキテクチャの Application 部分とその境界まわりを `port.in` / `port.out` と `adapter.in` / `adapter.out` に細かく分解し、**入出力の境界（どこから入って、どこへ出ていくか）を強調したもの**と見ることができます。

つまり一言でいうと：

- オニオンアーキテクチャ：層（Layer）で内側を守るアーキテクチャ
- ヘキサゴナルアーキテクチャ：ポートとアダプタで境界を強調するアーキテクチャ

で、目指しているゴール自体はどちらも

* ドメイン中心
* 外界（UI/DB/外部システム）からの独立
* テスタビリティ向上

といったところでかなり近いです。

:::column: 結論：ヘキサゴナルはオニオンの上級バージョン（ともいえる）
構造的な観点では「ヘキサゴナル＝オニオンの application＋境界部分を、port と adapter に分解して“入出力の境界を強調したバージョン”」といえます
:::


## 4. まとめ：ヘキサゴナルをどう扱うか

最後に、ここまでの話を踏まえて、
**「ヘキサゴナルを採用するときにどう考えるか」**を簡単にまとめます。

### ヘキサゴナルを選ぶモチベーション

コバーン自身がスライドで挙げている「ポイント」は、ざっくり言うとこうです。([alistaircockburn.com][2])

* UI や DB がなくてもアプリケーションを動かせるようにする（テストしやすくする）
* DB が落ちてもアプリケーションのコアは生きているようにする
* 技術要素（UI/DB/外部サービス）をあとから差し替えやすくする
* ビジネスロジックが UI やデータサービスに漏れないようにする（逆も然り）

そのための手段として、

* Port という「会話の窓口」を定義し
* Adapter で技術的な詳細を外側に押し出し
* コアは Port だけを見て仕事をする

という構図を採ります。

### ただし、コストもある

コバーンはちゃんと「コスト」も書いています。([alistaircockburn.com][2])

* 各 Port ごとにフィールドや DI 設定が増える
* 型付き言語では Port 用のインタフェースやフォルダ構成が必要
* Configurator（構成ルート）の設計が必要

つまり、**きれいさと引き換えにクラスやインタフェースが増える**わけです。

### オニオン vs ヘキサゴナルの使い分け

個人的には、次のように考えています。

* **ドメイン中心の分離をしたいだけならオニオンで十分なことも多い**

  * Presentation / Application / Domain / Infrastructure のレイヤをきちんと分ける
  * 依存は外側 → 内側に揃える

* 一方で、
  「**入出力チャネルが多様・複雑（RESTもメッセージもBatchも）**」とか
  「**永続化や外部連携の差し替え・テストダブルの切り替えをかなり意識したい**」場合は、

  * Port / Adapter をはっきり切り出したヘキサゴナルの形にした方が
    コード上もチーム内コミュニケーション上もわかりやすくなる

> ヘキサゴナルは「常に正義」ではなく、
> **境界をどれくらい強調したいか／技術の変化にどれくらい備えたいか**に応じて選ぶもの

くらいに、少し力を抜いて捉えるのが良さそうだな、というのが今のところの感触です。

---

## おわりに

今回、自分がヘキサゴナルアーキテクチャに対してモヤモヤしていた

* 依存の向き（外→内）と port.in / application の関係
* 入力と出力で adapter の「implements 具合」が非対称に見える話
* port.in を interface にする意味（実装が 1 つしかなくても）
* オニオンとの構造的な違い

あたりを、元記事やスライドを読み返しつつ整理してみました。

原典を読むと、コバーンが言っていることはわりとシンプルで、

* アプリを「内側」と「外側」に分ける
* その境界を Port で表現する
* Adapter で外界との変換をやる
* 中身（ビジネスロジック）をそれらから守る

くらいの話です。そこに、

* Clean Architecture
* DDD
* Java / Spring のお作法

などいろいろなものが乗っかって、**「依存は必ずこう向け」「UseCase は必ず interface + impl」**といった**“都市伝説寄りのルール”**が付け足されていった結果、
ちょっと難しく見え過ぎているのかな、という印象も持ちました。

ヘキサゴナルもオニオンも、
**「ドメインを守り、外界からの影響を局所化したい」**というゴールはかなり共通しています。

* そこまで境界を細かく切らなくても回るシステムなら、オニオンくらいの粒度で十分かもしれません。
* 境界やポートを明示したい／入出力チャネルが多様／将来の差し替えを強く意識したい、というなら、ヘキサゴナルの形を選ぶ価値が出てきます。

そんな感じで、**適材適所で「境界の強さ」を調整するための選択肢**として、
ヘキサゴナルをツールボックスの中に入れておいてもらえれば十分かな、と思います。


[1]: https://alistair.cockburn.us/hexagonal-architecture?utm_source=chatgpt.com "hexagonal-architecture - Alistair Cockburn"
[2]: https://alistaircockburn.com/Hexagonal%20Budapest%2023-05-18.pdf?utm_source=chatgpt.com "Hexagonal Architecture ( Ports & Adapters )"
[3]: https://en.wikipedia.org/wiki/Hexagonal_architecture_%28software%29?utm_source=chatgpt.com "Hexagonal architecture (software)"
