---
title: Kubernetesマニフェスト作成 - バッチアプリケーション
author: noboru-kudo
date: 2022-01-30
prevPage: ./src/posts/k8s-tutorial/app/web-app.md
---

[前回](/containers/k8s/tutorial/app/web-app/)は、ローカル環境のKubernetesでタスク管理ツールのWebアプリケーションを動かすことができました。

今回は日次でタスク完了レポートを出力するバッチアプリケーションを作成してみましょう。
Kubernetesを利用する主なメリットとして、セルフヒーリングによる耐障害性強化や、大規模トラフィックに耐えられるスケーラビリティが得られる等の印象が強いかと思います。
このような背景から、Kubernetesを持続的な稼働が求められるWeb/API用のものと想像する方が多いですが、バッチ処理のようなワンショットなワークロードにも対応しています。

今回作成するレポート出力機能は以下の構成になります。

![](https://i.gyazo.com/33e539dccf8bb554919cb2ddc034f0b9.png)

WebアプリケーションでDynamoDBに蓄積したタスク情報から、前日完了したタスクをレポート(CSVファイル)として作成し、S3に保管するものです。

それでは早速開始しましょう。

[[TOC]]

## 事前準備

Webアプリケーションが構築されていることが前提となります。
未実施の場合は[前回](/containers/k8s/tutorial/app/web-app/)を参考に、ローカル環境をセットアップしてください。

## 利用するKubernetesリソース

今回はCronJobリソース(オブジェクト)を使用してジョブをセットアップします。
CronJob自体はJobリソースを指定時間に実行するだけのものですので、まずはJobを抑えておきましょう。

### Job
ワンショットなアプリケーションの実行し、そのステータスを管理します。
JobはDeploymentと違い、指定した全てのPod(バッチ)が正常に終了した場合(exit code=0)は、再起動等は行いません。

ワンショットなアプリケーション自体は、単純にPodを作成するだけでも実行可能ですが、異常終了の考慮や並列実行等をする場合は、それ以外に多くの作業が必要になります。
Jobを利用することで、リトライやタイムアウト、並列実行等のバッチ固有の作業をKubernetes側に委ねることができます。

Jobでよく使われるパラメータには、主に以下があります。

| パラメータ | 内容
| -------- | ------------------------------------------
| backoffLimit | リトライ回数。失敗したPodは指定した回数(デフォルトは6回)リトライされ、全て失敗するとジョブは`Failed`ステータスになります。
| activeDeadlineSeconds | Jobの開始から指定した秒数を経過しても終了しない場合に、Podを強制終了させます。
| completions | 指定した回数Podを作成・実行します。`completionMode: Indexed`と併用すれば、環境変数`JOB_COMPLETION_INDEX`から現在の実行中のPodのインデックスを識別できます。
| parallelism | 指定数分のPodが並列に実行されます。`completions`と組み合わせて利用します。
| ttlSecondsAfterFinished | ジョブの実行完了(成功、失敗ともに)後にJobと配下のPodを残す時間。この間は完了したPodのログ等を確認できます。

マスタデータの取り込みや、データエクスポート等の単純なものは、ほとんどがこれで賄えますが、組織によってバッチアプリケーションは様々な要件があると思います[^2]。
Jobの実装パターンは、公式ドキュメントで整理されていますので、プロジェクトにあったバッチ方式を検討する上で参考にすると良いでしょう。

- <https://kubernetes.io/docs/concepts/workloads/controllers/job/#job-patterns>

[^2]: SpringBatch等の起動オーバーヘッドが大きい場合は毎回Podを起動するJobではなく、Deploymentとして常時Podを起動しておいてHTTP等で起動することも考えられます。また、他の選択肢としてワークフローエンジンの採用も検討すると良いでしょう。

### CronJob

その名の通り、CronJobは指定したスケジュールでJobを生成します。
Jobはその生成時に一度だけ実行しますが、CronJobでラップすることで、指定した時刻にJobを実行するジョブスケジューラの役割を果たします[^3]。

[^3]: もちろん、JP1のようなジョブスケジューラを既に利用している場合は、あえてCronJobを利用する必要はありません。

毎時0分に2並列で多重実行するバッチの場合は、以下のようなイメージになります。

![](https://i.gyazo.com/3f96acbe0d4cb116a62ad193aaca39d7.png)

このようにCronJobは指定されたスケジュールでJobを作成ます。JobはPodを作成してバッチ処理を指定された並列度で実行します。
バッチ処理が失敗した場合は、指定された回数再実行（新しいPodを生成）します。

CronJob固有のものだと、以下のパラメータがよく利用されます。

| パラメータ                | 内容
| ----------------------- | ------------------------------------------
| schedule                | 必須属性。Cronフォーマットでスケジュールを記述します。[こちら](https://crontab.guru/)を参考に設定すると良いでしょう。
| concurrencyPolicy       | 前のジョブが実行中のまま次のジョブ実行時間が到来した場合のポリシー(`Forbid`/`Allow`)を指定します。
| failedJobsHistoryLimit  | 失敗したJobを残す世代数を指定します。
| successfulJobsHistoryLimit | 成功したJobを残す世代数を指定します。
| startingDeadlineSeconds | ジョブが指定した時刻に起動できなかった場合にどのくらいの時刻超過での起動を許容するかを指定します。
| suspend                 | 障害等で一時的にバッチ処理を停止したい場合に`true`を指定します。

## 環境セットアップ

では、ここからバッチアプリケーションをローカル環境で動かしていきましょう。

## マニフェストファイル作成

## アプリケーションのデプロイ

## 動作確認

## まとめ

## クリーンアップ